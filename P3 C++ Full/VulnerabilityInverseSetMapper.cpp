#include "VulnerabilityInverseSetMapper.h"
#include <iostream>
#include <vector>
#include <unordered_set>
#include <algorithm>
#include <iomanip>

using namespace std;

void VulnerabilityInverseSetMapper::unordered_map_SQL_upload(vector<string> &input_data_vector)
{
    cve_id_map[input_data_vector.at(0)] = {input_data_vector.at(1), input_data_vector.at(2), input_data_vector.at(3), input_data_vector.at(4), input_data_vector.at(5), input_data_vector.at(6), stof(input_data_vector.at(7))};
}

void VulnerabilityInverseSetMapper::set_and_multimap_add_and_sort()
{
    //iterate through each ID value of cve_id_map
    for (const auto& [key, data] : cve_id_map) {
        //for every CVSS score we come across, if there is no vector at that CVSS score, create one
        //otherwise- if the key doesnt already exist, push back an additional key to the vector containing all CVE IDs corresponding to that CVSS score
        auto& vec = cvss_tree[data.cvss];
        if (std::find(vec.begin(), vec.end(), key) == vec.end()) {
            vec.push_back(key);
        }

        //add each CVE ID to the corresponding data value key as an additional entry in the set corresponding to that data value
        date_index[data.published_date].insert(key);
        vendor_index[data.vendor].insert(key);
        product_index[data.product].insert(key);
        os_index[data.os_type].insert(key);
        severity_index[data.severity].insert(key);
    }
}


void VulnerabilityInverseSetMapper::set_and_multimap_print_by_input(string date_search, string vendor_search,
                                                                    string product_search, string os_search,
                                                                    string sev_search) {
    int counter = 0;
    int validation_counter = 0;
    vector<unordered_set<string>> set_grabber;
    unordered_set<string> intersection_valid;

    //for each inputted search parameter, search for the particular parameter set within our inverse set maps and append that set of CVE IDs to set_grabber
    if (!date_search.empty()) set_grabber.push_back(date_index[date_search]);
    if (!vendor_search.empty()) set_grabber.push_back(vendor_index[vendor_search]);
    if (!product_search.empty()) set_grabber.push_back(product_index[product_search]);
    if (!os_search.empty()) set_grabber.push_back(os_index[os_search]);
    if (!sev_search.empty()) set_grabber.push_back(severity_index[sev_search]);

    if(set_grabber.empty())
    {
        for (const auto &[cvss, cve_ids]: cvss_tree) {
            for (const auto & id: cve_ids) {
                const DataTable& table_reference = cve_id_map[id];
                counter++;
                cout << id << " | " << fixed << setprecision(1) <<
                     table_reference.cvss << " | " << "vendor: " << std::left << std::setw(12) <<
                     table_reference.vendor << " | " << "product: " << std::left << std::setw(15) <<
                     table_reference.product << " | " << "severity: " << std::setw(6) <<
                     table_reference.severity << " | " << std::setw(10) <<
                     table_reference.published_date << " | " << endl;
//                     table_reference.description << endl;
            }
        }
        cout << "total search hits: " << counter << endl;
        return;
    }

    //initalize intersection value with first set (irrelevent which set you start with but must have some elements to compare)
    intersection_valid = set_grabber[0];
    //we will loop through every set in set_grabber starting at index 1 because we initialize with index 0
    for (int i = 1; i < set_grabber.size(); ++i) {
        unordered_set<string> pass_through_intersection;
        //for every existing cve_id, an element of the intersection, if the cve_id is in set_grabber[i], keep it, otherwise discard it (i.e. if this element is not in another set, discard it)
        for (const auto &cve_id: intersection_valid) {
            //if the cve_id exists in the next set_grabber index (i.e. for a particular parameter), append it to pass_through_intersection instead of erasing to avoid errors
            if (set_grabber[i].count(cve_id)) {
                //valid intersection between existing valid elements and the particular param set? append to pass_through_intersection
                pass_through_intersection.insert(cve_id);
            }
            //continue passing through to make sure all search parameters contain the element in their set
        }
        //using std::move allows us to avoid making a deep copy of pass_through_intersection, more time efficient
        intersection_valid = std::move(pass_through_intersection);
    }
    //for every CVE ID vector corresponding to some CVSS score
    for (const auto &[cvss, cve_ids]: cvss_tree) {
        //for every CVE ID within CVE ID vector
        for (const auto & id: cve_ids) {
            //if this CVE ID is within our intersection set, print its data
            if (intersection_valid.count(id)) {
                const auto &table_reference = cve_id_map[id];
                cout << id << " | " << fixed << setprecision(1) <<
                     table_reference.cvss << " | " << "vendor: " << std::left << std::setw(12) <<
                     table_reference.vendor << " | " << "product: " << std::left << std::setw(15) <<
                     table_reference.product << " | " << "severity: " << std::setw(6) <<
                     table_reference.severity << " | " << std::setw(10) <<
                     table_reference.published_date << " | " << endl;
//                     table_reference.description << endl;
                counter++;
            }
        }
    }
    cout << "total search hits: " << counter << endl;
}