#include "VulnerabilityInverseSetMapper.h"
#include <iostream>
#include <vector>
#include <unordered_set>
#include <algorithm>
#include <iomanip>

using namespace std;

void VulnerabilityInverseSetMapper::unordered_map_SQL_upload()
{
    cve_id_map["4729A"] = {"12/07/2020", "Remote code execution vulnerability", "Microsoft", "Edge", "Windows", "high", 9.1f};
    cve_id_map["1836T"] = {"03/03/2015", "Privilege escalation flaw", "Apple", "Safari", "Mac OS", "medium", 6.4f};
    cve_id_map["9375K"] = {"29/09/2018", "Buffer overflow in image processing", "Adobe", "Photoshop", "Windows", "high", 8.7f};
    cve_id_map["5081J"] = {"22/01/2022", "Authentication bypass via token reuse", "Google", "Chrome", "Linux", "high", 9.5f};
    cve_id_map["6723N"] = {"10/10/2011", "Information disclosure via cache timing", "Intel", "Firmware", "Windows", "low", 3.2f};
    cve_id_map["3517F"] = {"17/04/2019", "Cross-site scripting vulnerability", "Mozilla", "Firefox", "Linux", "medium", 5.8f};
    cve_id_map["9264B"] = {"01/06/2009", "Heap corruption when parsing files", "Oracle", "Java", "Windows", "high", 8.1f};
    cve_id_map["7902L"] = {"05/12/2016", "Insecure deserialization flaw", "Apache", "Struts", "Linux", "high", 9.3f};
    cve_id_map["7912L"] = {"05/12/2016", "Insecure deserialization flaw", "Apache", "Struts", "Linux", "high", 9.3f};
    cve_id_map["7922L"] = {"05/12/2016", "Insecure deserialization flaw", "Apache", "Struts", "Linux", "high", 9.3f};
    cve_id_map["2391V"] = {"28/03/2013", "SQL injection via crafted query", "PostgreSQL", "psql", "Linux", "medium", 6.0f};
    cve_id_map["6648X"] = {"16/08/2005", "Directory traversal vulnerability", "Cisco", "IOS", "Windows", "low", 2.7f};
    cve_id_map["6649X"] = {"16/08/2005", "Directory traversal vulnerability", "Apache", "IOS", "Windows", "high", 2.7f};
    cve_id_map["6249X"] = {"16/08/2005", "Directory traversal vulnerability", "Apache", "TestProd", "Windows", "high", 2.6f};
}

void VulnerabilityInverseSetMapper::set_and_multimap_add_and_sort()
{
    //iterate through each ID value of cve_id_map
    for (const auto& [key, data] : cve_id_map) {
        //for every CVSS score we come across, if there is no vector at that CVSS score, create one
        //otherwise- if the key doesnt already exist, push back an additional key to the vector containing all CVE IDs corresponding to that CVSS score
        auto& vec = cvss_tree[data.cvss];
        if (std::find(vec.begin(), vec.end(), key) == vec.end()) {
            vec.push_back(key);
        }

        //add each CVE ID to the corresponding data value key as an additional entry in the set corresponding to that data value
        date_index[data.published_date].insert(key);
        vendor_index[data.vendor].insert(key);
        product_index[data.product].insert(key);
        os_index[data.os_type].insert(key);
        severity_index[data.severity].insert(key);
    }
}


void VulnerabilityInverseSetMapper::set_and_multimap_print_by_input(string date_search, string vendor_search,
                                                                    string product_search, string os_search,
                                                                    string sev_search) {
    int counter = 0;

    vector<unordered_set<string>> set_grabber;
    unordered_set<string> intersection_valid;

    //for each inputted search parameter, search for the particular parameter set within our inverse set maps and append that set of CVE IDs to set_grabber
    if (!date_search.empty()) set_grabber.push_back(date_index[date_search]);
    if (!vendor_search.empty()) set_grabber.push_back(vendor_index[vendor_search]);
    if (!product_search.empty()) set_grabber.push_back(product_index[product_search]);
    if (!os_search.empty()) set_grabber.push_back(os_index[os_search]);
    if (!sev_search.empty()) set_grabber.push_back(severity_index[sev_search]);

    //initalize intersection value with first set (irrelevent which set you start with but must have some elements to compare)
    intersection_valid = set_grabber[0];
    //we will loop through every set in set_grabber starting at index 1 because we initialize with index 0
    for (int i = 1; i < set_grabber.size(); ++i) {
        unordered_set<string> pass_through_intersection;
        //for every existing cve_id, an element of the intersection, if the cve_id is in set_grabber[i], keep it, otherwise discard it (i.e. if this element is not in another set, discard it)
        for (const auto &cve_id: intersection_valid) {
            //if the cve_id exists in the next set_grabber index (i.e. for a particular parameter), append it to pass_through_intersection instead of erasing to avoid errors
            if (set_grabber[i].count(cve_id)) {
                //valid intersection between existing valid elements and the particular param set? append to pass_through_intersection
                pass_through_intersection.insert(cve_id);
            }
            //continue passing through to make sure all search parameters contain the element in their set
        }
        //using std::move allows us to avoid making a deep copy of pass_through_intersection, more time efficient
        intersection_valid = std::move(pass_through_intersection);
    }
    //for every CVE ID vector corresponding to some CVSS score
    for (const auto &[cvss, cve_ids]: cvss_tree) {
        //for every CVE ID within CVE ID vector
        for (const auto & id: cve_ids) {
            //if this CVE ID is within our intersection set, print its data
            if (intersection_valid.count(id)) {
                const auto &table_reference = cve_id_map[id];
                cout << id << " | " <<
                     table_reference.cvss << " | " << std::left << std::setw(10) <<
                     table_reference.vendor << " | " << std::left << std::setw(10) <<
                     table_reference.product << " | " << "severity: " << std::setw(6) <<
                     table_reference.severity << " | " << std::setw(10) <<
                     table_reference.published_date << " | " <<
                     table_reference.description << endl;
                counter++;
            }
        }
    }
    cout << "total search hits: " << counter << endl;
}